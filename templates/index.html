{% extends "base.html" %}

{% block title %}Cat√°logo de Produtos{% endblock %}

{% block content %}
<div class="catalog-header-compact">
    <!-- Linha 1: Busca + Favoritos -->
    <div class="search-favorites-row">
        <div class="search-box-compact" style="flex: 1; max-width: 600px;">
            <input type="text" id="searchInput" placeholder="Buscar produtos..." style="width: 100%; padding: 12px 15px; font-size: 16px;">
        </div>
        <button class="btn-favorites-compact" id="btnFavorites" onclick="toggleFavoritesFilter()">
            <span>‚≠ê</span>
            <span class="favorites-count" id="favoritesCount">0</span>
        </button>
        <button class="btn-favorites-compact" id="btnQueima" onclick="toggleQueimaFilter()" style="background: #ff6b35; margin-left: 8px;" title="Produtos em Queima de Estoque">
            <span>üî•</span>
            <span class="queima-count" id="queimaCount">0</span>
        </button>
    </div>
</div>

<!-- Mensagem inicial -->
<div class="search-prompt search-prompt-compact" id="searchPrompt">
    <div class="search-prompt-icon">üîç</div>
    <p>Busque produtos, selecione uma marca ou clique em ‚≠ê para ver favoritos</p>
</div>

<!-- Grid de produtos (inicialmente vazio) -->
<div class="products-grid" id="productsGrid" style="display: none;">
</div>

<!-- Pagina√ß√£o -->
<div class="pagination" id="pagination" style="display: none;">
</div>

<!-- Mensagem quando n√£o h√° resultados -->
<div class="no-results" id="noResults" style="display: none;">
    <p>Nenhum produto encontrado</p>
</div>

<!-- Bot√£o flutuante do carrinho -->
<button class="cart-float" id="cartButton" onclick="toggleCart()">
    <span class="cart-icon">üõí</span>
    <span class="cart-count" id="cartCount">0</span>
</button>

<!-- Carrinho lateral -->
<div class="cart-sidebar" id="cartSidebar">
    <div class="cart-header">
        <h2>Carrinho</h2>
        <button class="btn-close" onclick="toggleCart()">√ó</button>
    </div>
    <div class="cart-items" id="cartItems">
        <p class="empty-cart">Carrinho vazio</p>
    </div>
    <div class="cart-footer" style="display: none;">
        <button class="btn btn-primary btn-block" onclick="sendToWhatsApp()">
            üì± Enviar Pedido
        </button>
    </div>
</div>

<!-- Modal de detalhes do produto -->
<div class="modal" id="productModal">
    <div class="modal-content">
        <span class="modal-close" onclick="closeModal()">&times;</span>
        <div id="modalBody">
            <!-- Conte√∫do carregado dinamicamente -->
        </div>
    </div>
</div>

<script>
let cart = {};
let products = {{ products_json | tojson }};
let whatsappNumber = null;
let favorites = JSON.parse(localStorage.getItem('favorites_{{ session.get("categoria_loja", "") }}') || '[]');
let showingFavoritesOnly = false;
let showingQueimaOnly = false;
const PRODUCTS_PER_PAGE = 10;
let currentPage = 1;
let totalFilteredProducts = [];

// DEBUG: Verificar se h√° produtos em queima
console.log('Total de produtos carregados:', products.length);
console.log('Produtos em queima:', products.filter(p => p.em_queima_estoque === true).length);
console.log('Primeiros produtos:', products.slice(0, 3));

// Fun√ß√£o para calcular similaridade fuzzy entre duas strings (Levenshtein distance)
function fuzzySimilarity(str1, str2) {
    if (!str1 || !str2) return 0;
    
    str1 = str1.toLowerCase().trim();
    str2 = str2.toLowerCase().trim();
    
    // Se uma string est√° contida na outra, score alto
    if (str1.includes(str2) || str2.includes(str1)) {
        return Math.max(str1.length, str2.length) / Math.min(str1.length, str2.length);
    }
    
    const len1 = str1.length;
    const len2 = str2.length;
    const maxLen = Math.max(len1, len2);
    
    if (maxLen === 0) return 1.0;
    
    // Calcular dist√¢ncia de Levenshtein
    const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(0));
    
    for (let i = 0; i <= len1; i++) matrix[0][i] = i;
    for (let j = 0; j <= len2; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= len2; j++) {
        for (let i = 1; i <= len1; i++) {
            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
                matrix[j][i - 1] + 1,
                matrix[j - 1][i] + 1,
                matrix[j - 1][i - 1] + indicator
            );
        }
    }
    
    const distance = matrix[len2][len1];
    const similarity = (maxLen - distance) / maxLen;
    
    return similarity;
}

// Pr√©-carregar n√∫mero do WhatsApp e atualizar contador de favoritos
(async function init() {
    try {
        const response = await fetch('/api/whatsapp-config');
        const config = await response.json();
        whatsappNumber = config.number;
    } catch (error) {
        console.error('Erro ao carregar configura√ß√£o do WhatsApp:', error);
    }
    updateFavoritesCount();
    updateQueimaCount();
    // Renderizar produtos na carga inicial
    filterAndDisplayProducts();
})();

function updateQueimaCount() {
    const queimaCount = products.filter(p => p.em_queima_estoque).length;
    document.getElementById('queimaCount').textContent = queimaCount;
}

function toggleQueimaFilter() {
    showingQueimaOnly = !showingQueimaOnly;
    showingFavoritesOnly = false; // Desativar filtro de favoritos
    document.getElementById('btnQueima').style.opacity = showingQueimaOnly ? '1' : '0.6';
    document.getElementById('btnFavorites').style.opacity = '0.6';
    
    // Limpar busca ao ativar filtro
    if (showingQueimaOnly) {
        document.getElementById('searchInput').value = '';
    }
    
    currentPage = 1;
    filterAndDisplayProducts();
}

// Busca com debounce para melhor performance
let searchTimeout;
document.getElementById('searchInput').addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        currentPage = 1; // Resetar para primeira p√°gina ao buscar
        filterAndDisplayProducts();
    }, 300);
});

// Fun√ß√£o de busca melhorada - encontra produtos mesmo com palavras em ordem diferente
function matchesSearchTerms(productName, productBrand, searchTerm) {
    if (!searchTerm) return { matches: true, score: 0 };

    const searchWords = searchTerm.toLowerCase().split(/\s+/).filter(w => w.length > 0);
    const productText = (productName + ' ' + productBrand).toLowerCase();
    const productWords = productText.split(/\s+/);

    let matchCount = 0;
    let totalScore = 0;

    for (const searchWord of searchWords) {
        let wordMatched = false;

        // Verificar se a palavra existe no texto do produto (substring completo)
        for (const productWord of productWords) {
            // Match exato de palavra
            if (productWord === searchWord) {
                wordMatched = true;
                totalScore += 10;
                break;
            }
            // Match no in√≠cio da palavra (para "ve" em "verniz")
            else if (productWord.startsWith(searchWord)) {
                wordMatched = true;
                totalScore += 5;
                break;
            }
            // Match em qualquer posi√ß√£o (para "niz" em "verniz")
            else if (productWord.includes(searchWord) && searchWord.length >= 2) {
                wordMatched = true;
                totalScore += 3;
                break;
            }
        }

        if (wordMatched) {
            matchCount++;
        }
    }

    // TODAS as palavras precisam fazer match
    const matches = matchCount === searchWords.length;

    // Bonus por match no in√≠cio do nome
    if (matches && productName.toLowerCase().startsWith(searchWords[0])) {
        totalScore += 20;
    }

    return { matches, score: totalScore };
}

function filterAndDisplayProducts() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();

    const searchPrompt = document.getElementById('searchPrompt');
    const productsGrid = document.getElementById('productsGrid');
    const noResults = document.getElementById('noResults');
    const pagination = document.getElementById('pagination');

    // Ocultar prompt sempre (mostrar produtos)
    searchPrompt.style.display = 'none';

    // Filtrar produtos com busca melhorada
    let filteredProducts = [];
    let otherProducts = []; // Produtos n√£o favoritos que correspondem √† busca

    for (const p of products) {
        const searchResult = matchesSearchTerms(p.name, p.brand, searchTerm);
        const isFavorite = favorites.includes(p.id);
        const emQueima = p.em_queima_estoque;

        // Se tem busca, prevalece a busca mesmo com filtro de queima
        if (searchTerm) {
            // Modo busca - ignora filtro de queima
            if (searchResult.matches) {
                if (showingFavoritesOnly) {
                    if (isFavorite) {
                        filteredProducts.push({ ...p, searchScore: searchResult.score, isFavoriteResult: true });
                    } else {
                        otherProducts.push({ ...p, searchScore: searchResult.score, isFavoriteResult: false });
                    }
                } else {
                    filteredProducts.push({ ...p, searchScore: searchResult.score });
                }
            }
        } else if (showingQueimaOnly) {
            // Sem busca, mas filtrando por queima
            if (emQueima) {
                filteredProducts.push({ ...p, searchScore: 100 });
            }
        } else if (showingFavoritesOnly) {
            // Sem busca, filtrando favoritos
            if (isFavorite) {
                filteredProducts.push({ ...p, searchScore: 100 });
            }
        } else {
            // Sem busca e sem filtros - mostrar todos
            filteredProducts.push({ ...p, searchScore: 0 });
        }
    }

    // Ordenar por relev√¢ncia (score maior primeiro)
    if (searchTerm) {
        filteredProducts.sort((a, b) => b.searchScore - a.searchScore);
        otherProducts.sort((a, b) => b.searchScore - a.searchScore);
    }

    // Adicionar produtos relacionados (catalisadores) - inserir logo apos o produto principal
    if (searchTerm) {
        const addedRelatedIds = new Set();
        const productsWithRelated = [];

        // Primeiro, processar filteredProducts e inserir relacionados logo apos cada produto
        for (let i = 0; i < filteredProducts.length; i++) {
            const foundProduct = filteredProducts[i];
            productsWithRelated.push(foundProduct);

            // Se este produto TEM um produto relacionado e ainda nao foi adicionado
            if (foundProduct.related_product_id && !addedRelatedIds.has(foundProduct.related_product_id)) {
                const relatedProduct = products.find(p => p.id === foundProduct.related_product_id);

                // Verificar se o relacionado nao esta ja na lista original
                const alreadyInList = filteredProducts.some(p => p.id === foundProduct.related_product_id) ||
                                      otherProducts.some(p => p.id === foundProduct.related_product_id);

                if (relatedProduct && !alreadyInList) {
                    console.log('Inserindo catalisador:', relatedProduct.name, 'apos', foundProduct.name);
                    const relatedCopy = { ...relatedProduct };
                    relatedCopy.isRelated = true;
                    relatedCopy.relatedTo = foundProduct.name;
                    relatedCopy.isFavoriteResult = favorites.includes(relatedProduct.id);
                    relatedCopy.searchScore = foundProduct.searchScore - 0.5; // Score ligeiramente menor para ficar logo apos

                    // Inserir logo apos o produto principal
                    productsWithRelated.push(relatedCopy);
                    addedRelatedIds.add(foundProduct.related_product_id);
                }
            }
        }

        filteredProducts = productsWithRelated;
        console.log('Total de produtos apos adicionar relacionados:', filteredProducts.length);
    }

    // Se est√° nos favoritos, tem busca, adiciona os outros produtos ap√≥s os favoritos
    if (showingFavoritesOnly && searchTerm && otherProducts.length > 0) {
        filteredProducts = [...filteredProducts, ...otherProducts];
    }

    // Guardar produtos filtrados para pagina√ß√£o
    totalFilteredProducts = filteredProducts;

    if (filteredProducts.length === 0) {
        productsGrid.style.display = 'none';
        noResults.style.display = 'block';
        pagination.style.display = 'none';
        return;
    }

    // Calcular pagina√ß√£o
    const totalPages = Math.ceil(filteredProducts.length / PRODUCTS_PER_PAGE);

    // Garantir que p√°gina atual √© v√°lida
    if (currentPage > totalPages) currentPage = totalPages;
    if (currentPage < 1) currentPage = 1;

    // Obter produtos da p√°gina atual
    const startIndex = (currentPage - 1) * PRODUCTS_PER_PAGE;
    const endIndex = startIndex + PRODUCTS_PER_PAGE;
    const displayProducts = filteredProducts.slice(startIndex, endIndex);

    noResults.style.display = 'none';
    productsGrid.style.display = 'grid';

    // Renderizar produtos com separador para "outros resultados" quando em modo favoritos
    let html = '';
    let showedOthersSeparator = false;

    for (const p of displayProducts) {
        // Se estamos nos favoritos e este produto n√£o √© favorito, mostrar separador
        if (showingFavoritesOnly && searchTerm && p.isFavoriteResult === false && !showedOthersSeparator) {
            html += `<div class="other-results-separator">
                <span>Outros resultados encontrados</span>
            </div>`;
            showedOthersSeparator = true;
        }
        html += createProductCard(p);
    }

    productsGrid.innerHTML = html;

    // Renderizar pagina√ß√£o
    renderPagination(totalPages, filteredProducts.length);
}

function renderPagination(totalPages, totalItems) {
    const pagination = document.getElementById('pagination');

    if (totalPages <= 1) {
        pagination.style.display = 'none';
        return;
    }

    pagination.style.display = 'flex';

    let html = '';

    // Bot√£o anterior
    html += `<button class="pagination-btn ${currentPage === 1 ? 'disabled' : ''}"
             onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
             ‚Äπ Anterior
             </button>`;

    // N√∫meros das p√°ginas
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    // Ajustar se estiver no final
    if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    // Primeira p√°gina se n√£o vis√≠vel
    if (startPage > 1) {
        html += `<button class="pagination-btn" onclick="goToPage(1)">1</button>`;
        if (startPage > 2) {
            html += `<span class="pagination-ellipsis">...</span>`;
        }
    }

    // P√°ginas vis√≠veis
    for (let i = startPage; i <= endPage; i++) {
        html += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}"
                 onclick="goToPage(${i})">${i}</button>`;
    }

    // √öltima p√°gina se n√£o vis√≠vel
    if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
            html += `<span class="pagination-ellipsis">...</span>`;
        }
        html += `<button class="pagination-btn" onclick="goToPage(${totalPages})">${totalPages}</button>`;
    }

    // Bot√£o pr√≥ximo
    html += `<button class="pagination-btn ${currentPage === totalPages ? 'disabled' : ''}"
             onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
             Pr√≥ximo ‚Ä∫
             </button>`;

    // Info de total
    const startItem = (currentPage - 1) * PRODUCTS_PER_PAGE + 1;
    const endItem = Math.min(currentPage * PRODUCTS_PER_PAGE, totalItems);
    html += `<span class="pagination-info">Mostrando ${startItem}-${endItem} de ${totalItems}</span>`;

    pagination.innerHTML = html;
}

function goToPage(page) {
    const totalPages = Math.ceil(totalFilteredProducts.length / PRODUCTS_PER_PAGE);
    if (page < 1 || page > totalPages) return;

    currentPage = page;
    filterAndDisplayProducts();

    // Rolar para o topo da grade de produtos
    document.getElementById('productsGrid').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Fun√ß√£o para escapar caracteres especiais em HTML
function escapeHtml(text) {
    if (!text) return '';
    return text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&#39;');
}

function createProductCard(product) {
    const isFavorite = favorites.includes(product.id);
    const currentQty = cart[product.id] ? cart[product.id].qty : 0;
    const safeName = escapeHtml(product.name);
    const safeBrand = escapeHtml(product.brand);
    const relatedBadge = product.isRelated ?
        `<div class="related-badge">üîó Catalisador de ${escapeHtml(product.relatedTo)}</div>` : '';
    const queimaBadge = product.em_queima_estoque ?
        `<div class="queima-badge">üî• QUEIMA DE ESTOQUE üî•</div>` : '';

    return `
        <div class="product-card ${product.em_queima_estoque ? 'product-card-queima' : ''}" data-id="${product.id}" data-name="${safeName}" data-brand="${safeBrand}">
            ${queimaBadge}
            ${relatedBadge}
            <button class="btn-favorite ${isFavorite ? 'active' : ''}" onclick="toggleFavorite(${product.id})" title="${isFavorite ? 'Remover dos favoritos' : 'Adicionar aos favoritos'}">
                ${isFavorite ? '‚≠ê' : '‚òÜ'}
            </button>
            <div class="product-image" onclick="openModal(${product.id})">
                ${product.image ?
                    `<img src="${product.image}" alt="${product.name}">` :
                    '<div class="no-image">Sem imagem</div>'}
            </div>
            <div class="product-info">
                <h3 class="product-name">${product.name}</h3>
                <p class="product-brand">${product.brand}</p>
                ${product.em_queima_estoque && product.preco_original && product.preco_queima ?
                    `<div class="product-price-queima">
                        <span class="price-original">R$ ${parseFloat(product.preco_original).toFixed(2)}</span>
                        <span class="price-queima">R$ ${parseFloat(product.preco_queima).toFixed(2)}</span>
                        <span class="price-discount">${Math.round((1 - product.preco_queima / product.preco_original) * 100)}% OFF</span>
                    </div>` :
                    ''
                }
            </div>
            <div class="product-actions">
                <button class="btn-qty btn-minus" onclick="changeQty(${product.id}, -1)">-</button>
                <input type="number" id="qty-${product.id}" value="${currentQty}" min="0" class="qty-input"
                       onchange="updateQty(${product.id}, this.value)">
                <button class="btn-qty btn-plus" onclick="changeQty(${product.id}, 1)">+</button>
            </div>
        </div>
    `;
}

function toggleFavorite(productId) {
    const index = favorites.indexOf(productId);
    if (index > -1) {
        favorites.splice(index, 1);
    } else {
        favorites.push(productId);
    }
    localStorage.setItem('favorites_{{ session.get("categoria_loja", "") }}', JSON.stringify(favorites));
    updateFavoritesCount();

    // Atualizar visual do bot√£o
    const btn = document.querySelector(`[data-id="${productId}"] .btn-favorite`);
    if (btn) {
        btn.classList.toggle('active');
        btn.innerHTML = favorites.includes(productId) ? '‚≠ê' : '‚òÜ';
    }

    // Se estiver mostrando apenas favoritos, atualizar lista
    if (showingFavoritesOnly) {
        filterAndDisplayProducts();
    }
}

function updateFavoritesCount() {
    document.getElementById('favoritesCount').textContent = favorites.length;
}

function toggleFavoritesFilter() {
    showingFavoritesOnly = !showingFavoritesOnly;
    showingQueimaOnly = false; // Desativar filtro de queima
    const btn = document.getElementById('btnFavorites');
    btn.classList.toggle('active', showingFavoritesOnly);
    document.getElementById('btnQueima').style.opacity = '0.6';

    // Limpar busca ao ativar filtro
    if (showingFavoritesOnly) {
        document.getElementById('searchInput').value = '';
    }

    currentPage = 1; // Resetar para primeira p√°gina
    filterAndDisplayProducts();
}

function changeQty(productId, delta) {
    const input = document.getElementById(`qty-${productId}`);
    let newValue = parseInt(input.value) + delta;
    if (newValue < 0) newValue = 0;
    input.value = newValue;
    updateQty(productId, newValue);
}

function updateQty(productId, qty) {
    qty = parseInt(qty);
    if (qty < 0) qty = 0;

    if (qty === 0) {
        delete cart[productId];
    } else {
        const card = document.querySelector(`[data-id="${productId}"]`);
        cart[productId] = {
            name: card.dataset.name,
            brand: card.dataset.brand,
            qty: qty
        };
    }

    updateCartDisplay();
}

function updateCartDisplay() {
    const cartItems = document.getElementById('cartItems');
    const cartCount = document.getElementById('cartCount');
    const cartFooter = document.querySelector('.cart-footer');

    const hasItems = Object.keys(cart).length > 0;

    // PRIMEIRA COISA: Mostrar/esconder bot√£o INSTANTANEAMENTE
    if (hasItems) {
        cartFooter.style.display = 'block';
        cartFooter.style.opacity = '1';
        cartFooter.style.visibility = 'visible';
    } else {
        cartFooter.style.display = 'none';
    }

    // DEPOIS: Atualizar contador
    const totalItems = Object.values(cart).reduce((sum, item) => sum + item.qty, 0);
    cartCount.textContent = totalItems;

    // POR √öLTIMO: Atualizar lista de itens
    if (!hasItems) {
        cartItems.innerHTML = '<p class="empty-cart">Carrinho vazio</p>';
        return;
    }

    // Montar HTML de forma otimizada
    const items = Object.entries(cart).map(([id, item]) => `
        <div class="cart-item">
            <div class="cart-item-info">
                <strong>${item.name}</strong>
                <span>Quantidade: ${item.qty}</span>
            </div>
            <button class="btn-remove" onclick="removeFromCart(${id})">√ó</button>
        </div>
    `).join('');

    cartItems.innerHTML = `<div class="cart-list">${items}</div>`;
}

function removeFromCart(productId) {
    delete cart[productId];
    document.getElementById(`qty-${productId}`).value = 0;
    updateCartDisplay();
}

function toggleCart() {
    const sidebar = document.getElementById('cartSidebar');
    sidebar.classList.toggle('active');
}

function sendToWhatsApp() {
    if (Object.keys(cart).length === 0) {
        alert('Carrinho vazio! Adicione produtos antes de enviar.');
        return;
    }

    if (!whatsappNumber) {
        alert('N√∫mero do WhatsApp n√£o configurado. Entre em contato com o administrador.');
        return;
    }

    // Pegar nome do usu√°rio da sess√£o
    const username = '{{ session.get("username", "Cliente") }}'.toUpperCase();

    // Montar mensagem no formato: PEDIDO - NOME_DO_CLIENTE
    let message = `PEDIDO - ${username}\n\n`;

    for (let [id, item] of Object.entries(cart)) {
        const productName = item.name.toUpperCase();
        
        // Procurar o produto para verificar se est√° em queima e pegar o pre√ßo
        const product = products.find(p => p.id == id);
        
        if (product && product.em_queima_estoque && product.preco_queima) {
            // Produto em queima de estoque - mostrar pre√ßo
            const preco = parseFloat(product.preco_queima).toFixed(2);
            const precoTotal = (parseFloat(product.preco_queima) * item.qty).toFixed(2);
            message += `- ${productName}  -  ${item.qty} unid  -  R$ ${preco} (Total: R$ ${precoTotal})\n\n`;
        } else {
            // Produto normal - sem pre√ßo
            message += `- ${productName}  -  ${item.qty} unid\n\n`;
        }
    }

    // Redirecionar para WhatsApp
    const whatsappUrl = `https://wa.me/${whatsappNumber}?text=${encodeURIComponent(message)}`;
    window.open(whatsappUrl, '_blank');

    // Limpar carrinho
    cart = {};
    document.querySelectorAll('.qty-input').forEach(input => input.value = 0);
    updateCartDisplay();

    toggleCart();
}

function openModal(productId) {
    const product = products.find(p => p.id === productId);
    const modal = document.getElementById('productModal');
    const modalBody = document.getElementById('modalBody');

    modalBody.innerHTML = `
        <div class="modal-product">
            ${product.image ? `<img src="${product.image}" alt="${product.name}">` : '<div class="no-image">Sem imagem</div>'}
            <h2>${product.name}</h2>
            <p class="product-brand"><strong>Marca:</strong> ${product.brand}</p>
            <div class="product-description">
                <h3>Descri√ß√£o:</h3>
                <p>${product.description || 'Sem descri√ß√£o dispon√≠vel'}</p>
            </div>
        </div>
    `;

    modal.style.display = 'flex';
}

function closeModal() {
    document.getElementById('productModal').style.display = 'none';
}

// Fechar modal ao clicar fora
window.onclick = function(event) {
    const modal = document.getElementById('productModal');
    if (event.target === modal) {
        closeModal();
    }
}
</script>

{% endblock %}
